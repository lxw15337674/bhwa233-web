import { useRequest, useLocalStorageState, useSetState, useMemoizedFn, useMount } from 'ahooks';
import { FFmpeg } from '@ffmpeg/ffmpeg';
import {
    initializeFFmpeg,
    analyzeMediaFile,
    analyzeAudioInfo,
    analyzeMediaMetadata,
    convertAudio,
    checkMultiThreadSupport,
    AudioInfo,
    MediaMetadata,
    AudioFormat,
    QualityMode,
    ConversionState
} from '@/utils/audioConverter';

// FFmpeg ÁÆ°ÁêÜ Hook
export const useFFmpegManager = () => {
    const {
        data: ffmpegData,
        loading: ffmpegLoading,
        error: ffmpegError,
        run: initFFmpeg
    } = useRequest(
        async () => {
            const result = await initializeFFmpeg();
            return result;
        },
        {
            manual: true,
            cacheKey: 'ffmpeg-instance',
            staleTime: Infinity,
            onError: (error) => {
                console.error('FFmpeg Âä†ËΩΩÂ§±Ë¥•:', error);

                let errorMessage = `FFmpeg Âä†ËΩΩÂ§±Ë¥•: ${error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ'}`;

                if (error instanceof Error) {
                    if (error.message.includes('SharedArrayBuffer')) {
                        errorMessage += '\n\nüí° Â§öÁ∫øÁ®ãÊ®°ÂºèÈúÄË¶ÅÁâπÊÆäÈÖçÁΩÆÔºö\n‚Ä¢ ËØ∑Á°Æ‰øùÊúçÂä°Âô®ÈÖçÁΩÆ‰∫ÜÊ≠£Á°ÆÁöÑ HTTP Â§¥\n‚Ä¢ Â∞ùËØïÂà∑Êñ∞È°µÈù¢ÈáçËØï\n‚Ä¢ Á≥ªÁªü‰ºöËá™Âä®ÈôçÁ∫ßÂà∞ÂçïÁ∫øÁ®ãÊ®°Âºè';
                    } else if (error.message.includes('Network')) {
                        errorMessage += '\n\nüí° Ëß£ÂÜ≥Âª∫ËÆÆÔºö\n‚Ä¢ Ê£ÄÊü•ÁΩëÁªúËøûÊé•\n‚Ä¢ Â∞ùËØïÂà∑Êñ∞È°µÈù¢\n‚Ä¢ Â¶ÇÊûú‰ΩøÁî®VPNÔºåËØ∑Â∞ùËØïÂÖ≥Èó≠ÂêéÈáçËØï';
                    } else if (error.message.includes('CORS') || error.message.includes('cross-origin')) {
                        errorMessage += '\n\nüí° ËøôÂèØËÉΩÊòØÊµèËßàÂô®Ë∑®ÂüüÈôêÂà∂ÂØºËá¥ÁöÑÔºåËØ∑Â∞ùËØïÔºö\n‚Ä¢ Âà∑Êñ∞È°µÈù¢ÈáçËØï\n‚Ä¢ ‰ΩøÁî®Áé∞‰ª£ÊµèËßàÂô®ÔºàChrome„ÄÅFirefox„ÄÅSafariÔºâ\n‚Ä¢ Ê£ÄÊü•ÊµèËßàÂô®ÊòØÂê¶ÈòªÊ≠¢‰∫ÜË∑®ÂüüËØ∑Ê±Ç';
                    } else if (error.message.includes('timeout') || error.message.includes('load')) {
                        errorMessage += '\n\nüí° Âä†ËΩΩË∂ÖÊó∂ÔºåËØ∑Â∞ùËØïÔºö\n‚Ä¢ Âà∑Êñ∞È°µÈù¢ÈáçËØï\n‚Ä¢ Ê£ÄÊü•ÁΩëÁªúËøûÊé•Á®≥ÂÆöÊÄß\n‚Ä¢ ‰ΩøÁî®Êõ¥Âø´ÁöÑÁΩëÁªúÁéØÂ¢É';
                    }
                }

                throw new Error(errorMessage);
            }
        }
    );

    useMount(() => {
        initFFmpeg();
    });

    return {
        ffmpeg: ffmpegData?.ffmpeg,
        isMultiThread: ffmpegData?.isMultiThread || false,
        ffmpegLoaded: !!ffmpegData,
        ffmpegLoading,
        ffmpegError,
        initFFmpeg
    };
};

// Áªü‰∏ÄÂ™í‰ΩìÂàÜÊûê HookÔºà‰ºòÂåñÁâàÊú¨ - Âø´ÈÄüÂàÜÊûê + Ë∂ÖÊó∂Â§ÑÁêÜÔºâ
export const useUnifiedMediaAnalysis = (ffmpeg: FFmpeg | undefined) => {
    const {
        data: analysisResult,
        loading: isAnalyzing,
        error: analyzeError,
        run: runAnalysis
    } = useRequest(
        async (file: File) => {
            if (!ffmpeg) {
                throw new Error('FFmpeg not loaded');
            }

            console.log(`ÂºÄÂßãÂø´ÈÄüÂàÜÊûêÊñá‰ª∂: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
            const startTime = Date.now();

            try {
                const result = await analyzeMediaFile(file, ffmpeg);
                const duration = Date.now() - startTime;
                console.log(`Êñá‰ª∂ÂàÜÊûêÂÆåÊàêÔºåËÄóÊó∂: ${duration}ms`);
                return result;
            } catch (error: any) {
                const duration = Date.now() - startTime;
                console.error(`Êñá‰ª∂ÂàÜÊûêÂ§±Ë¥•ÔºåËÄóÊó∂: ${duration}ms`, error);

                // Êèê‰æõÊõ¥ÂèãÂ•ΩÁöÑÈîôËØØ‰ø°ÊÅØ
                if (error.message?.includes('timeout')) {
                    throw new Error('Êñá‰ª∂ÂàÜÊûêË∂ÖÊó∂ÔºåËØ∑Â∞ùËØïÈÄâÊã©ËæÉÂ∞èÁöÑÊñá‰ª∂ÊàñÈáçËØï');
                } else if (error.message?.includes('not loaded')) {
                    throw new Error('FFmpeg Êú™Âä†ËΩΩÂÆåÊàêÔºåËØ∑Á≠âÂæÖÂä†ËΩΩÂÆåÊàêÂêéÈáçËØï');
                } else {
                    throw new Error(`Êñá‰ª∂ÂàÜÊûêÂ§±Ë¥•: ${error.message || 'Êú™Áü•ÈîôËØØ'}`);
                }
            }
        },
        {
            manual: true,
            refreshDeps: [ffmpeg],
            onError: (error) => {
                console.error('Media analysis failed:', error);
            },
            onSuccess: (result) => {
                if (result?.audioInfo) {
                    console.log('Èü≥È¢ë‰ø°ÊÅØ:', result.audioInfo);
                }
                if (result?.metadata) {
                    console.log('Â™í‰ΩìÂÖÉÊï∞ÊçÆ:', result.metadata);
                }
            }
        }
    );

    const analyzeMedia = useMemoizedFn((file: File) => {
        if (!ffmpeg) {
            console.log('FFmpeg not loaded, skipping media analysis');
            return;
        }

        // Êñá‰ª∂Â§ßÂ∞èÊ£ÄÊü•ÔºàÂèØÈÄâÁöÑÈ¢ÑÈò≤Êé™ÊñΩÔºâ
        const fileSizeMB = file.size / 1024 / 1024;
        if (fileSizeMB > 500) { // 500MB ‰ª•‰∏äÁöÑÊñá‰ª∂ÁªôÂá∫ÊèêÁ§∫
            console.warn(`Êñá‰ª∂ËæÉÂ§ß (${fileSizeMB.toFixed(2)}MB)ÔºåÂàÜÊûêÂèØËÉΩÈúÄË¶ÅËæÉÈïøÊó∂Èó¥`);
        }

        runAnalysis(file);
    });

    return {
        audioInfo: analysisResult?.audioInfo || null,
        mediaMetadata: analysisResult?.metadata || null,
        isAnalyzing,
        analyzeError: analyzeError?.message || null,
        analyzeMedia,
        clearAnalysis: () => {
            // Ê∏ÖÁ©∫ÂàÜÊûêÁªìÊûú
        }
    };
};

// Èü≥È¢ëÂàÜÊûê HookÔºà‰øùÁïôÂêëÂêéÂÖºÂÆπÊÄßÔºâ
export const useAudioAnalysis = (ffmpeg: FFmpeg | undefined) => {
    const {
        data: audioInfo,
        loading: isAnalyzing,
        error: analyzeError,
        run: runAnalysis
    } = useRequest(
        async (file: File) => {
            if (!ffmpeg) {
                throw new Error('FFmpeg not loaded');
            }
            return await analyzeAudioInfo(file, ffmpeg);
        },
        {
            manual: true,
            refreshDeps: [ffmpeg],
            onError: (error) => {
                console.error('Audio analysis failed:', error);
            }
        }
    );

    const analyzeAudio = useMemoizedFn((file: File) => {
        if (!ffmpeg) {
            console.log('FFmpeg not loaded, skipping audio analysis');
            return;
        }
        runAnalysis(file);
    });

    return {
        audioInfo,
        isAnalyzing,
        analyzeError: analyzeError?.message || null,
        analyzeAudio,
        clearAnalysis: () => {
            // Ê∏ÖÁ©∫ÂàÜÊûêÁªìÊûú
        }
    };
};

// Â™í‰ΩìÂÖÉÊï∞ÊçÆÂàÜÊûê Hook
export const useMediaMetadataAnalysis = (ffmpeg: FFmpeg | undefined) => {
    const {
        data: mediaMetadata,
        loading: isAnalyzing,
        error: analyzeError,
        run: runAnalysis
    } = useRequest(
        async (file: File) => {
            if (!ffmpeg) {
                throw new Error('FFmpeg not loaded');
            }
            return await analyzeMediaMetadata(file, ffmpeg);
        },
        {
            manual: true,
            refreshDeps: [ffmpeg],
            onError: (error) => {
                console.error('Media metadata analysis failed:', error);
            }
        }
    );

    const analyzeMetadata = useMemoizedFn((file: File) => {
        if (!ffmpeg) {
            console.log('FFmpeg not loaded, skipping metadata analysis');
            return;
        }
        runAnalysis(file);
    });

    return {
        mediaMetadata,
        isAnalyzing,
        analyzeError: analyzeError?.message || null,
        analyzeMetadata,
        clearMetadata: () => {
            // Ê∏ÖÁ©∫ÂÖÉÊï∞ÊçÆÁªìÊûú
        }
    };
};

// Èü≥È¢ëËΩ¨Êç¢ Hook
export const useAudioConversion = (ffmpeg: FFmpeg | undefined, isMultiThread: boolean) => {
    const [conversionState, setConversionState] = useSetState<ConversionState>({
        isConverting: false,
        progress: 0,
        currentStep: '',
        error: null,
        outputFile: null,
        outputFileName: '',
        remainingTime: null,
    });

    const {
        loading: isConverting,
        run: runConversion
    } = useRequest(
        async (file: File, outputFormat: AudioFormat, qualityMode: QualityMode) => {
            if (!ffmpeg) {
                throw new Error('FFmpeg not loaded');
            }

            setConversionState({
                isConverting: true,
                progress: 0,
                currentStep: 'ÂáÜÂ§áËΩ¨Êç¢...',
                error: null,
                outputFile: null,
                remainingTime: null
            });

            const outputBlob = await convertAudio(
                file,
                ffmpeg,
                outputFormat,
                qualityMode,
                isMultiThread,
                (progress, step, remainingTime) => {
                    setConversionState({
                        progress,
                        currentStep: step,
                        remainingTime: remainingTime || null
                    });
                }
            );

            const finalFileName = `${file.name.split('.')[0]}.${outputFormat}`;

            setConversionState({
                isConverting: false,
                progress: 100,
                currentStep: 'ËΩ¨Êç¢ÂÆåÊàêÔºÅ',
                outputFile: outputBlob,
                outputFileName: finalFileName,
                remainingTime: null
            });

            // Ê∏ÖÈô§ÂÆåÊàêÁä∂ÊÄÅ
            setTimeout(() => {
                setConversionState({
                    currentStep: '',
                    progress: 0
                });
            }, 2000);

            return outputBlob;
        },
        {
            manual: true,
            refreshDeps: [ffmpeg, isMultiThread],
            onError: (error) => {
                console.error('ËΩ¨Êç¢Â§±Ë¥•:', error);
                setConversionState({
                    isConverting: false,
                    progress: 0,
                    currentStep: '',
                    error: `ËΩ¨Êç¢Â§±Ë¥•: ${error instanceof Error ? error.message : 'Êú™Áü•ÈîôËØØ'}`
                });
            }
        }
    );

    const startConversion = useMemoizedFn(
        (file: File, outputFormat: AudioFormat, qualityMode: QualityMode) => {
            if (!ffmpeg) {
                setConversionState({
                    error: 'FFmpeg Êú™Âä†ËΩΩÂÆåÊàêÔºåËØ∑Á®çÂÄôÂÜçËØï'
                });
                return;
            }
            runConversion(file, outputFormat, qualityMode);
        }
    );

    const resetConversion = useMemoizedFn(() => {
        setConversionState({
            isConverting: false,
            progress: 0,
            currentStep: '',
            error: null,
            outputFile: null,
            outputFileName: '',
            remainingTime: null,
        });
    });

    return {
        conversionState,
        isConverting,
        startConversion,
        resetConversion
    };
};

// Êñá‰ª∂ÈÄâÊã© Hook
export const useFileSelection = () => {
    const [selectedFile, setSelectedFile] = useSetState<{ file: File | null }>({
        file: null
    });

    const [fileState, setFileState] = useSetState({
        dragOver: false
    });

    const selectFile = useMemoizedFn((file: File) => {
        setSelectedFile({ file });
    });

    const clearFile = useMemoizedFn(() => {
        setSelectedFile({ file: null });
    });

    const handleDragEnter = useMemoizedFn(() => {
        setFileState({ dragOver: true });
    });

    const handleDragLeave = useMemoizedFn(() => {
        setFileState({ dragOver: false });
    });

    const handleDrop = useMemoizedFn((e: React.DragEvent) => {
        e.preventDefault();
        setFileState({ dragOver: false });

        const files = Array.from(e.dataTransfer.files);
        if (files.length > 0) {
            selectFile(files[0]);
        }
    });

    return {
        selectedFile: selectedFile.file,
        dragOver: fileState.dragOver,
        selectFile,
        clearFile,
        handleDragEnter,
        handleDragLeave,
        handleDrop
    };
};

// Áî®Êà∑ËÆæÁΩÆ Hook
export const useAudioConverterSettings = () => {
    const [outputFormat, setOutputFormat] = useLocalStorageState<AudioFormat>(
        'audioConverter.outputFormat',
        { defaultValue: 'mp3' }
    );

    const [qualityMode, setQualityMode] = useLocalStorageState<QualityMode>(
        'audioConverter.qualityMode',
        { defaultValue: 'standard' }
    );

    const [isPlaying, setIsPlaying] = useSetState({
        playing: false
    });

    return {
        outputFormat,
        setOutputFormat,
        qualityMode,
        setQualityMode,
        isPlaying: isPlaying.playing,
        setIsPlaying: (playing: boolean) => setIsPlaying({ playing })
    };
};
